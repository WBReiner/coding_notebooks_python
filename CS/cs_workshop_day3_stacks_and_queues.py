# -*- coding: utf-8 -*-
"""cs-workshop-day3-stacks-and-queues.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sGwU8QIV3PBhBJxQPVBoqGVA98A9e-IK

## Review of what we've done so far


### [Day 1: Strings](https://colab.research.google.com/drive/180V8BvZGysucZMiKPSrnynCJJaL_xwcV)
Key is to treat strings as a "list of characters" which helped us manipulate and check for patterns.

Example Questions: 
 - "are these 2 strings permutations of each other?"
 - "is this string a palindrome?"
 - "is this string a permutation of a palindrome?"
 

### [Day 2: Linked Lists](https://colab.research.google.com/drive/1OPyOmOgzFebYAhTXB8WJjD71HETuNaID)
A linked list consists of a series of nodes starting with a **head node** 
Each node has a value (can be an int or whatever) and a pointer (an attribute of  **`.next`** or **`.prev`** which refers to another node)

   Vocab: A pointer is a CS term which means an address that points to the actual object in memory. Passing pointers is cheap, passing whole objects takes up redundant space. This is why pandas spits out an error everytime you accidentally make a copy of a slice of a dataframe when you just wanted to _refer_ to it.
 
 Example Questions:
  - "define a class which instantiates a Node with a value, a pointer to the previous node, and a pointer to the next node"
  - "define a function which will traverse the linked list given the head node"
  - "function to delete a node given the node's value and the head node\
"""



"""### Stacks - LIFO / FILO  (Last in First Out / First in Last Out)

![alt text](https://cdn-images-1.medium.com/max/1600/1*4Pn00ch_p4DTCb4r3naCDQ.png)
"""

# Using only native Python objects (Hint: use lists)
# Implement a class of object called Stack, which has the following methods:
#     pop - remove the item most recently added
#     push - push a value into the stack
#     peek - get the top value of the stack
#     size - get the size of the stack
#     is_empty - check if the stack is empty

#Ahmad
class Stack:
  def __init__(self):
    self.stack = []
    
  def push(self,value):
    return self.stack.append(value)
  
  def isEmpty(self):
    return self.stack == []
  
  def pop(self):
    return self.stack.pop()
  
  def size(self):
    return len(self.stack)
  
  def min(self):
    if self.isEmpty() == False:
      return min(self.stack)
    else:
      print('stack is empty')
  
  def peek(self): #which am I going to pop off so have to look at this and then do it
    return self.stack[-1]

natalieStack = Stack()
natalieStack.push(31)
natalieStack.push(16)
natalieStack.push(-100)
natalieStack.pop()
natalieStack.pop()
natalieStack.pop()
natalieStack.min()

# Stack Min: How would you design a stack which, 
# in addition to push and pop, has a function min
# which returns the minimum element? 
# Push, pop and min should all operate in 0(1) time.





"""## Stack of Plates
Imagine a (literal) stack of plates. 
If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. 
Implement a data structure SetOfStacks that mimics this. 
SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity. SetOfStacks. push() and SetOfStacks. pop() should behave identically to a single stack (that is, pop () should return the same values as it would if there were just a single stack).

FOLLOW UP
Implement a function popAt(int index) which performs a pop operation on a specific substack.
"""

class SetOfStacks(Stack):
  def __init__(self):
    self.stackos = []

#RIGHT HERE RIGHT NOW
class Stack:
  def __init__(self,capacity):
    self.stack = []
    self.capacity = capacity
    
  def push(self,value):
    return self.stack.append(value)
  
  def isEmpty(self):
    return self.stack == []
  
  def isfull(self):
    return self.size() == self.capacity

  def pop(self):
    return self.stack.pop()
  
  def size(self):
    return len(self.stack)
  
  def min(self):
    if self.isEmpty() == False:
      return min(self.stack)
    else:
      print('stack is empty')
  
  def peek(self): #which am I going to pop off so have to look at this and then do it
    return self.stack[-1]

wstack = Stack(3)

wstack.push(1)
wstack.push(3)
wstack.push(3)

wstack.stack

wstack.isfull()

wstack.size()

wstack.capacity

# Using only native Python objects (Hint: use lists)
# Implement a class of object called Queue, which has the following methods:
#     enqueue - add a value to the queue
#     dequeue - remove the first added value
#     peek - get the value of the head of the queue
#     size - get the size of the queue
#     is_empty - check if the queue is empty

#method-> defined within a class
#function-> defined OUTSIDE a class







"""### Queues (FIFO / LILO)

![alt text](https://cdn-images-1.medium.com/max/1600/1*FwL7mJ4qpQWZnommC5tsFQ.png)
"""

#Matt
class queue:
  def __init__(self):
    self.q = []
  
  def enqueue(self, value):
    return self.q.append(value)
  
  def dequeue(self):
    try:
      self.q.pop(0)
    except IndexError:
      return 'ya done goofed it up'
    
  def peek(self):
    return self.q[0]
  
  def size(self):
    return len(self.q)
  
  def is_empty(self):
    return len(self.q) == 0

a = queue()
a.enqueue(2)
a.enqueue(4)
a.enqueue(6)
a.enqueue(8)
a.is_empty()

#Whitney stack is books or pancackes
#queue is a queue
class doaqueue:
  def __init__(self):
    self.queue=[]
   
  def enqueue(self,value):
    return self.queue.append(value)
  
  def dequeue(self):
    return self.queue.pop(0)
  
  def peek(self): #which am I going to pop off so have to look at this and then do it
    return self.queue[0]

w = doaqueue()
w.enqueue(10)
print(w.queue)

w.dequeue()
w.enqueue(15)
print(w.queue)

w.enqueue(1)
print(w.queue)

w.enqueue(5)
print(w.queue)

w.peek()


make a queue from 2 stacks
#can I establish a queue from 2 stacks
#combine the two things

"""Using only native Python objects (Hint: use lists)
Implement a class of object called Queue, which has the following methods:

enqueue - add a value to the queue

dequeue - remove the first added value

peek - get the value of the head of the queue

size - get the size of the queue

is_empty - check if the queue is empty
"""

# Daniel (it werks) 
class dqueue:
  def __init__(self):
    self.queue = []
    
  def enqueue(self, value):
    return self.queue.append(value)
  
  def dequeue(self):
    return self.queue.pop()
  
  def peek(self):
    return self.queue[0]
  
  def size(self):
    return len(self.queue)
  
  def isEmpty(self):
    return self.queue == []

d = dqueue()
d.enqueue(44)
d.enqueue(22)
d.enqueue(11)
d.dequeue()
d.peek()
d.isEmpty()



## Natalie Morse

class queue:
  def __init__(self):
    self.q=[]
    
  def enqueue(self, value):##adds a new value to the que, this person has to wait behind those already in line#
    return self.q.append(value)
  
  def dequeue(self):#returns the person we should help first
    return self.q.pop(0)
  
  def peek(self):#returns the value that would be dequeued if we wanted to
    return self.q[0]

#Natalie test
myq=queue()
myq.enqueue(1)
myq.enqueue(9)
myq.enqueue(100)

myq.dequeue()

myq.peek()









#WhitneyReiner

#Stack- imagine a stack of pancakes- you can only remove the TOP one
#LIFO FIFO - order in which you add or remove
#queue is a line- can only FIFO
#enque is 
#deque is 

# defining a class in python
__init__ #initializes what we want in the class
#self is adding it to itself before it even becomes a thing

#stacks are how undo works- also do recursion works

class Stack:
  def __init__(self):
    self.stack = []
    
  def push(self, value):
    return self.stack.append(value)
  
  def isEmpty(self):
    return self.stack==[]
  
  def pop(self, value):
    return self.stack.pop()
  
  
  #pop means remove
  #the last thing is the thing at the end

## NAtalie Morse

class Stack:
  def __init__(self):
    self.stack = []
    
  def push(self, value):
    return self.stack.append(value)
  
  def isEmpty(self):
    return self.stack==[]
  
  def pop(self, value):
    return self.stack.pop()

#Matt. Does not work currently

class stack:
  def __init__(self):
    self.stack = []
    
  def push(self, val):
    return self.stack.append(val)

pancakes = stack()
pancakes.push(1)

# Daniel

class dstack:
  def __init__(self):
    self.dstack = []
    
  def push(self,value):
    return self.dstack.append(value)

  def isEmpty(self):
    return self.dstack == []

  def pop(self):
    return self.dstack.pop()

DanielStack = dstack()
DanielStack.push(67)
DanielStack.dstack



#Natalia
class dobedobeque:
  def __init__(self):
    self.queue = []
    
  def enqueue(self, value):
    return self.queue.append(value)
    
  def dequeue(self):
    return self.queue.pop(0)
  
  def size(self):
    if len(self.queue) is None:
      return 0
    else:
      return len(self.queue)
  
  def peek(self):
    return self.queue[0]
    
  def is_empty(self):
    return self.queue == []

natq=dobedobeque()
natq.size()
natq.is_empty()

natq.enqueue("chewbacca")
natq.enqueue("lumpy")
natq.enqueue("malla")
natq.dequeue()
natq.peek()



